#### 系统调用流程
系统调用流程是
设置系统调用号和中断向量号->ecall->trampoline->usertrap->syscall->原路返回


首先我们先来举个例子 C库中的write，他在xv6中的user/user.h中
实际上他只有一个函数名的描述，函数体实际是三行汇编

```C++
li  a7,SYS_write
//给a7寄存器赋值
ecall 
//进入内核
ret 
```
在上面函数中 SYS_write是什么呢？其实定义在kernel/syscall.h中，所有的系统调用号都在这个位置，也就是我们想要调用这个系统调用

**在这里系统调用号和中断向量号的区别是什么呢？**
因为中断向量号只有几百个，但是系统调用是远远超过中断向量号的个数的，所以一个很好的方法是，首先我们对不同的中断类型分类，然后再通过系统调用号来调用对应的系统调用     
通俗理解一下就是中断向量号是段基址，系统调用号是偏移量


**进入内核**
risc-v中ecall是进行系统调用的入口

（在这里补充一下risc-v的特权级别，UserMode->SupervisorMode->MachineMode）
(https://lucidreamiss.github.io/2022/11/03/risc-v%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/)
（在arm中有四个特权级别，多了一个虚拟机监控程序，可以帮助虚拟机绕过操作系统提升效率）

ecall会用到a0-a7，具体参数这里不细讲


我们继续看如何进入的内核态，首先将pc存在sepc，然后将pc的值修改为stvec的值，这是汇编语言执行的

我们顺着思路继续来，stvec在哪呢？其实他指向虚拟内存空间的最顶层（同时在内核虚拟空间和用户虚拟空间的最顶层都是这段代码，这一点很重要，在后边会用到），也就是max部分，也就是trampoline，可以理解为是从U到S的一个蹦床，但是需要注意，执行ecall之后就已经进入S态了，但是我们还不能执行内核代码，因为寄存器没保存，也没有切换页表

（这里是一个非常关键的地方！！！）
我们如何切换页表？假设我们直接切换页表，当我们执行完切换页表的操作之后，我们并不知道内核态页表的下一条指令是什么！我们如果直接切换那么系统就很容易崩溃，因为我们不知道我们下一条指向了什么，所以tranpoline的相同性就很有必要，我们切换页表后，执行的指令一样。


**保存用户信息**
在进入用户态之前，无论是进程启动或者恢复，都会设置sscratch指向trapframe（在kernel/proc.h），这个结构体存储当前进程一些乱七八糟的用户信息和内核信息

**切换到内核页表信息**
```C++
//从p->trapframe->kernel_sp处载入内核栈指针到sp寄存器
ld sp, 8(a0)

//让tp持有当前hartid，貌似是当前进程执行的CPU核心id
//hartid从p->trapframe->kernel_hartid处载入
ld tp, 32(a0)

//从p->trapframe->kernel_trap处载入`usertrap`函数的地址到t0寄存器
ld t0, 16(a0)

//从p->trapframe->kernel_satp恢复内核页表
ld t1, 0(a0)
csrw satp, t1

//执行内存屏障，确保内存访问的正确性和乱序等问题
//清空TLB缓存以保证切换页表后地址转换不会出错,也就是用户态的映射不能用了，毕竟我们已经进入了内核态
sfence.vma zero, zero
```

**处理中断**
好了现在我们已经成功进入了内核态了，我们该处理了，在上面我们已经将usertrap放到了寄存器里
执行完蹦床之后下一条就是jr，也就是跳转到usertrap

```C++
// 因为我们现在在内核中，使用的也是内核的页表
// 所以我们要重写stvec为内核中的陷阱向量位置
// 以处理后续（在内核中时）发生的陷入
w_stvec((uint64)kernelvec);

// 获取当前进程，实际上是通过读取tp寄存器中
// 保存的hartid获取到当前CPU，再通过当前CPU
// 获取其上的进程，也就是当前陷入的进程
struct proc *p = myproc();

// 在跳转到trampoline之前，用户pc被保存到了
// sepc寄存器中，现在，将它保存到进程的trapframe中
p->trapframe->epc = r_sepc();

...

// 如果进入usertrap的原因是由于系统调用，也就是中断向量号（由8标识）
if(r_scause() == 8){
    // 如果当前进程已经被杀掉了，不执行
    if(p->killed)
        exit(-1);

    // risc-v中每条指令是4字节，相当于跳过ecall指令，指向ecall的下一条
    p->trapframe->epc += 4;

    // 打开中断，risc-v的trap硬件总会关闭中断，在程序中打开
    // 让xv6可以在处理系统调用的过程中响应中断
    intr_on();
    // 调用syscall
    syscall();
} else if {...}
```

syscall就是执行对应的系统中断了


**返回用户态，也就是陷入返回usertrapret**

其实也是通过trampoline，这里不细讲了

